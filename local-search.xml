<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>蜂鸟E203</title>
    <link href="/2023/11/15/riscv-e203/"/>
    <url>/2023/11/15/riscv-e203/</url>
    
    <content type="html"><![CDATA[<h2 id="4-2-蜂鸟E200简介"><a href="#4-2-蜂鸟E200简介" class="headerlink" title="4.2 蜂鸟E200简介"></a>4.2 蜂鸟E200简介</h2><p>蜂鸟E200 系列处理器核的特性简介如下。</p><ul><li>采用两级流水线结构</li><li>能够运行RISC-V指令集，支持RV32I&#x2F;E&#x2F;A&#x2F;M&#x2F;C&#x2F;F&#x2F;D等指令子集的配置组合,支持机器模式（Machine Mode Only）</li><li>支持标准的JTAG调试接口以及成熟的软件调试工具</li><li>提供成熟的GCC编译工具链</li><li>配套SOC提供紧耦合系统IP模块，包括中断控制器、计时器、UART、QSPI和PWM等，即使能用（Ready-to-Use）的SoC平台与FPGA原型系统</li></ul><p>蜂鸟E200 系列处理器的系统示意图如图所示，提供丰富的存储和接口<br><img src="/media/e203_soc.png" alt="image"></p><ul><li>私有的ITCM与DTCM，实现指令与数据的分离存储同时提高性能</li><li>中断接口用于与SoC 级别的中断控制器连接</li><li>调试接口用于与soc 级别的JTAG 调试器连接</li><li>系统总线接口，用于访存指令或者数据</li><li>紧祸合的私有外设接口，用于访存数据</li><li>紧稠合的快速IO 接口，用于访存数据</li><li>所有的ITCM 、DTCM 、系统总线接口、私有外设接口以及快速IO 接口均可以配置地址区间</li></ul><h2 id="4-5-蜂鸟E200配套SOC"><a href="#4-5-蜂鸟E200配套SOC" class="headerlink" title="4.5 蜂鸟E200配套SOC"></a>4.5 蜂鸟E200配套SOC</h2><p><img src="/media/cpmplete_soc_platform.png" alt="image"><br><img src="/media/soc_submodule.png" alt="image"></p><h2 id="5-3-RTL-代码风格"><a href="#5-3-RTL-代码风格" class="headerlink" title="5.3 RTL 代码风格"></a>5.3 RTL 代码风格</h2><h3 id="5-3-1-使用标准DFF模块例化生成寄存器"><a href="#5-3-1-使用标准DFF模块例化生成寄存器" class="headerlink" title="5.3.1 使用标准DFF模块例化生成寄存器"></a>5.3.1 使用标准DFF模块例化生成寄存器</h3><p><img src="/media/code_style_dff.png" alt="image"><br><img src="/media/dff_type.png" alt="image"><br><img src="/media/std_always_block.png" alt="image"><br><img src="/media/assert_xstate.png" alt="image"></p><h3 id="5-3-2-推荐使用assign语法代替if-else和case语法"><a href="#5-3-2-推荐使用assign语法代替if-else和case语法" class="headerlink" title="5.3.2 推荐使用assign语法代替if-else和case语法"></a>5.3.2 推荐使用assign语法代替if-else和case语法</h3><p>Verilog 中的if-else 和 case语法存在两大缺点</p><ul><li>不能传播不定态</li><li>会产生优先级的选择电路而非并行选择电路，不利于时序和面积</li></ul><h2 id="5-4-蜂鸟E200模块层次划分"><a href="#5-4-蜂鸟E200模块层次划分" class="headerlink" title="5.4 蜂鸟E200模块层次划分"></a>5.4 蜂鸟E200模块层次划分</h2><p><img src="/media/module_hier.png" alt="image"><br><img src="/media/rtl_hier.png" alt="image"></p><h2 id="6-3-处理器流水"><a href="#6-3-处理器流水" class="headerlink" title="6.3 处理器流水"></a>6.3 处理器流水</h2><p>流水线存在的时序问题: 流水线越深，由于每一级流水线需要进行握手，流水线最后一级的反压信号可能会一直串扰到最前一级造成严重的反压时序问题</p><p>解决方法：</p><ul><li><p>取消握手：此方法能够杜绝反压的发生，时序表现非常好。但是取消握手，即意味着流水线中的每一级并不会与其下一级进行握手，可能会造成功能错误或者指令丢失。因此这种方法往往需要配合其他的机制， 譬如重执行（ Replay ）、预留大缓存等。</p></li><li><p>加入乒乓缓存：加入乒乓缓存（ Ping-pong Buffer ）是一种用面积换时序的方法，也是在解决反压的最简单方法。通过使用乒乓缓存（有两个表项〉替换掉普通的一级流水线（只有一个表项〉，可以使得此级流水线向上一级流水线的握手接收信号仅关注乒乓缓存中是否有一个以上有空的表项即可，而无需将下一级的握手接收信号串扰至上一级。<br><img src="/media/pingpong_buffer.png" alt="image"></p></li><li><p>加入前向旁路缓存：加入前向旁路缓存（ Forward Bypass Buffer ）也是一种用面积换<br>时序的方法，是在解决反压时的一种非常巧妙的方法。旁路缓存仅只有一个表项，由于增加了这一个额外的缓存表项，可以将后向的握手信号时序路径砍断，但是对前向路径不受影响，因此可以广泛使用于握手接口。蜂鸟E200 即于设计中采用此方法，有效地解决了多处反压造成的时序瓶颈。<br><img src="/media/reg_slice.png" alt="image"><br><a href="https://zipcpu.com/blog/2019/05/22/skidbuffer.html">https://zipcpu.com/blog/2019/05/22/skidbuffer.html</a></p></li></ul><h3 id="6-4-2-流水线中的数据冲突"><a href="#6-4-2-流水线中的数据冲突" class="headerlink" title="6.4.2 流水线中的数据冲突"></a>6.4.2 流水线中的数据冲突</h3><p>WAW和WAR可以通过寄存器重命名的方法将相关性去除</p><ul><li>寄存器重命名技术在Tomasulo算法中通过保留站和ROB完成，或者采用纯物理寄存器（而不用ROB）的方式完成</li></ul><p>RAW是真数据相关，无法通过寄存器重命名的方式去除相关性，后序的指令要使用前级指令执行完成的结果，从而造成流水线停顿，为了减少流水线停顿带来的性能损失，可以采用“动态调度”</p><ul><li>采用数据旁路传播（Data Bypass and Forward）技术</li><li>尽量让后续指令在等待过程中不阻塞流水线，而让其他无关的指令继续顺利执行</li><li>早期的Tomasulo算法中通过保留站可以达到上述两方面的功效，但是保留站保存了操作数，无法做到深度很大</li><li>最新的高性能处理器普遍采用在每个运算单元前配置乱序发射队列（Issue Queue）的方式，发射队列仅追踪RAW 相关性，而并不存放操作数，因此可以做到很深（譬如16 个表项〉。在发射队列中的指令一旦相关性解除之后，再从发射队列中发射出来读取物理寄存器组（ Physical Register File ），然后发送给运算单元开始计算。</li></ul><h2 id="6-5-蜂鸟E200处理器的流水线"><a href="#6-5-蜂鸟E200处理器的流水线" class="headerlink" title="6.5 蜂鸟E200处理器的流水线"></a>6.5 蜂鸟E200处理器的流水线</h2><p><img src="/media/e200_pipeline_struct.png" alt="image"></p><h2 id="7-1-取指"><a href="#7-1-取指" class="headerlink" title="7.1 取指"></a>7.1 取指</h2><h3 id="7-1-1-取指特点"><a href="#7-1-1-取指特点" class="headerlink" title="7.1.1 取指特点"></a>7.1.1 取指特点</h3><ul><li>指令的编码长度可以不相等，有的指令编码宽度是16位，有的是32位。对于32位的指令，其对应PC地址可能与32位地址边界不对齐</li></ul><h3 id="7-1-3-如何处理非对齐指令"><a href="#7-1-3-如何处理非对齐指令" class="headerlink" title="7.1.3 如何处理非对齐指令"></a>7.1.3 如何处理非对齐指令</h3><ol><li>普通指令非对齐，使用Leftover buffer</li><li>分支跳转指令非对齐，使用多bank sram进行指令存储。常见的奇偶交错方式为例，使用两块32位SRAM交错存储，两个连续的32位指令分别存储在不同的SRAM。对于32位地址不对齐的指令，一个周期同时访问两块SRAM取出连续的32位指令字，各取一部分进行拼接成需要的23位指令</li></ol><h3 id="7-1-4-如何处理分支指令"><a href="#7-1-4-如何处理分支指令" class="headerlink" title="7.1.4 如何处理分支指令"></a>7.1.4 如何处理分支指令</h3><ol><li>分支指令类型：RISC-V没有带条件间接跳转跳转&#x2F;分支指令，对于这种指令，流水线只有在执行阶段完成后才能解析最终跳转结果，会stall流水线，影响性能为了提高性能，现代处理采用分支预测（Branch Prediction）技术<ul><li>预测方向</li><li>预测地址</li></ul></li><li>预测方向</li></ol><ul><li>静态预测<ul><li>静态预测总是预测不跳转（在译码阶段得出真正预测结果，用delay slot减少流水线冲刷造成的性能损失）</li><li>BTFN(Back Taken， Forward Not Taken)，for循环生成的汇编往往使用向后跳转（PC小）的分支指令</li></ul></li><li>动态预测<ul><li>一比特饱和计数器：喜爱次分支指令永远使用上一次记录的方向作为本次预测</li><li>两比特饱和计数器</li></ul></li></ul><ol start="3"><li>预测地址</li></ol><ul><li>BTB（Branch Target Bufer），缓存分支指令的PC以及跳转目标地址。不能太大，不能应用于间接跳转&#x2F;分支指令</li><li>RAS（Return Address Stack）使用容量有限的硬件堆栈（先进后出）存储函数调用的返回地址。<ul><li>函数的调用和返回在程序中往往是成对出现的，因此可以在函数调用（使用分支跳转指令）时将当前PC 值加4 （或者2 ） 。即其顺序执行的下一条指令的PC 值压入孔气S 堆枝中，等到函数返回（使用分支跳转指令〉时将RAS中的值弹出，这样就可以快速地为该函数返回的分支跳转指令预测目标地址。</li><li>多层嵌套哦那个一造成堆栈溢出</li></ul></li><li>Indirect BTB</li></ul><h2 id="7-2-RISC-V架构特点对于取指的简化"><a href="#7-2-RISC-V架构特点对于取指的简化" class="headerlink" title="7.2 RISC-V架构特点对于取指的简化"></a>7.2 RISC-V架构特点对于取指的简化</h2><p><img src="/media/jump_branch_instructions.png" alt="image"></p><h2 id="7-3-IFU"><a href="#7-3-IFU" class="headerlink" title="7.3 IFU"></a>7.3 IFU</h2><h3 id="7-3-1-整体设计思路"><a href="#7-3-1-整体设计思路" class="headerlink" title="7.3.1 整体设计思路"></a>7.3.1 整体设计思路</h3><p><img src="/media/ifu.png" alt="image"><br><img src="/media/ifu_macro_arch.png" alt="image"></p><p>主要包括如下功能：</p><ul><li>对取回地址简单译码（Mini-Decode）</li><li>简单的分支预测（Simple-BPU）</li><li>生成取指的PC（PC生成）</li><li>根据PC地址访问ITCM或BIU（地址判断和ICB总线控制）</li></ul><p>(1)针对”快”的设计理念</p><ul><li>假定绝大多数取指都发生在ITCM，没有I-Cache，使用ITCM满足实时性要求</li><li>ITCM使用单周期访问的SRAM</li><li>某些特殊情况，指令需要从外部存储器中读取（比如上电引导程序从外部Flash读取）。此时IFU通过BIU使用系统存储器接口访问外部存储器，访问延迟不可能做到单周期，对这种特殊情况不做优化<br>(2)针对”连续不断”的设计思路</li><li>每个周期都能生成下一条待取指令的PC，因此需要判断本指令是普通指令还是分支跳转指令，需要对当前取回的指令进行译码</li><li>将取回的指令在同周期进行部分译码，如果是分支跳转指令，直接在同周期进行分支预测，使用译码得到的信息和分支预测的信息进行下一条待取指令PC的生成</li><li>在一个周期内完成读回指令，译码，分支预测，PC生成操作，理论上可以做到背靠背取指令</li><li>上述操作是一条关键时序路径，可能会制约主频</li></ul><p>分支预测：</p><ul><li>静态分支预测</li><li>back taken</li></ul><h3 id="8-3-3-decode"><a href="#8-3-3-decode" class="headerlink" title="8.3.3 decode"></a>8.3.3 decode</h3><h4 id="RV32I"><a href="#RV32I" class="headerlink" title="RV32I"></a>RV32I</h4><p><img src="/media/RV32I_instr.png" alt="image"><br><img src="/media/RV32I_format.png" alt="iamge"><br><img src="/media/RV32I_instr_encode.png" alt="image"></p><h4 id="RV32C"><a href="#RV32C" class="headerlink" title="RV32C"></a>RV32C</h4><p><img src="/media/RV32C_instr.png" alt="image"><br><img src="/media/RV32C_format.png" alt="image"><br><img src="/media/RV32C_00.png" alt="image"><br><img src="/media/RV32C_01.png" alt="image"><br><img src="/media/RV32C_10.png" alt="image"></p><h4 id="RV32M"><a href="#RV32M" class="headerlink" title="RV32M"></a>RV32M</h4><p><img src="/media/RV32M_instr.png" alt="image"><br><img src="/media/RV32M_instr_encode.png" alt="image"></p><h4 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h4><p><img src="/media/ABI.png" alt="image"></p><h2 id="10-3-机器模式下的异常处理"><a href="#10-3-机器模式下的异常处理" class="headerlink" title="10.3 机器模式下的异常处理"></a>10.3 机器模式下的异常处理</h2><p><img src="/media/exception.png" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>RISC-V CPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>e203</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test-artical</title>
    <link href="/2023/11/15/test-artical/"/>
    <url>/2023/11/15/test-artical/</url>
    
    <content type="html"><![CDATA[<p>This is a test page !!!<br><img src="/test-artical/BOOT_SET.png" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
